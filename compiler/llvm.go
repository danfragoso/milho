package compiler

import (
	"fmt"

	"github.com/danfragoso/milho/mir"
)

var llvm_header = `
;LLVM IR GENERATED BY THE MILHO COMPILER
;2021
`
type llvm_instruction interface {
	String() string
}

type llvm_instruction_nop struct {} 

func (i *llvm_instruction_nop) String() string {
	return ""
}

func llvm_generateMain(entrypoint llvm_instruction) string {
	generatedMain := fmt.Sprintf(`
@milho_rval = global i32 0
	
define i32 @main() {
	;START USER CODE
	%s
	;END USER CODE

	%%1 = load i32, i32* @milho_rval
	ret i32 %%1 
}`, entrypoint.String())

	return generatedMain
}

func TranspileLLVM(expr mir.Expression) string {
	voidEntrypoint := &llvm_instruction_nop{}
	return llvm_header + llvm_generateMain(voidEntrypoint)
}

func llvm_transpileExpr(expr mir.Expression) string {
	switch expr.Type() {
	case mir.ListExpr:
		return llvm_transpileListExpr(expr).String()
	}

	return "call void @llvm.donothing()"
}

func llvm_transpileListExpr(expr mir.Expression) llvm_instruction {
	expressions := expr.(*mir.ListExpression).Expressions
	if len(expressions) == 0 {
		return &JSValue_Undefined{}
	}

	firstExpr := expressions[0]
	switch firstExpr.Type() {
	case mir.SymbolExpr:
		sym := firstExpr.(*mir.SymbolExpression)
		return matchListSymbolExpr(sym, expressions[1:])
	}

	return &JSValue_String{}
}
